# ITEM61) 박싱된 기본 타입보다는 기본 타입을 사용하라

### 1. 기본타입과 박싱된 기본 타입의 차이

1. 오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수느 있다.
2. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이란 속성을 갖는다.
    
    → 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별할 수 있다.
    
3. 박싱된 기본 타입은 null값을 가질 수 있다.
4. 기본 타입이 시간과 메모리 사용면에서 더 효율적이다.

- 박싱된 기본 타입에 == 연산자를 사용하면 오류가 발생한다.

```java
Comparator<Integer> naturalOrder = 
	(i, j) -> (i < j) -1 : (i == j ? 0 : 1);
```

- 실무에서는 Comparator.naturalOrder() 사용하자.
- 비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다.
- 그렇더라도 이 문제를 고치려면 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한 다음, 모든 비교를 기본 타입 변수로 수행해야 한다.

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> (
	int i = iBoxed, j = jBoxed; //오토박싱
	return i < j ? -1 : (i=j ? 0 : 1);
};
```

- 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. 그리고 null 참조를 언박싱하면 NullPointerException이 발생한다.
- 기본 타입과 박싱된 기본 타입의 차이를 무시하고 혼용해서 사용하면 성능 문제로 이어진다.

### 2. 박싱된 기본 타입을 사용해야 하는 경우

1. 컬렉션의 원소,  키, 값 → 컬렉션은 기본 타입을 담을 수 없다.
2. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로 사용
    
    → 자바 언어가 타입 매개변수로 기본 타입을 지원하지 않기 때문
    
    ```java
    ThreadLocal<int> // X
    ThreadLocal<Integer> // O 
    ```
    
3. 리플렉션을 통해 메서드를 호출할 때
    
    ```java
    String str = new String("Class Test");
    Class<? extends String> cls = str.class;
    ```